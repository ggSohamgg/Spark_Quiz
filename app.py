from flask import Flask, render_template, request, jsonify
import os
import requests

# Initialize the Flask application
app = Flask(__name__)

# Retrieve the OpenRouter API key from environment variables
OPENROUTER_API_KEY = os.environ.get("OPENROUTER_API_KEY")

# Set the endpoint URL for the OpenRouter API
OPENROUTER_URL = "https://openrouter.ai/api/v1/chat/completions "

# Define the model to be used (Qwen 3 30B A3B Free Tier)
MODEL = "qwen/qwen3-30b-a3b:free"


def generate_quiz(parameters):
    """
    Builds a prompt based on user parameters, sends it to the OpenRouter API,
    and returns the quiz generated by the LLM in Markdown format.
    
    Args:
        parameters (dict): User-defined settings including topic, difficulty, question types, etc.

    Returns:
        dict: Contains the quiz content as a string in Markdown format.
    """

    # Check if at least one question has been requested
    total_questions = sum(parameters['type_counts'].get(t, 0) for t in parameters['question_types'])
    if total_questions <= 0:
        return {
            "quiz_text": "Error: Please request at least one question.\n\nNo questions were requested. Please select at least one question type with a quantity greater than 0."
        }

    # Ensure that the OpenRouter API key is configured
    if not OPENROUTER_API_KEY:
        return {
            "quiz_text": "Error: API key not configured.\n\nThe OPENROUTER_API_KEY environment variable is not set. Please configure it to use the OpenRouter API."
        }

    # Build the prompt dynamically using the provided parameters
    prompt = f"Generate a quiz with the following parameters:\n"
    prompt += f"- Topic: {parameters['topic']}\n"
    prompt += f"- Difficulty: {parameters['difficulty']}\n"

    # Format question types with their respective counts
    type_lines = []
    for t in parameters['question_types']:
        count = parameters['type_counts'].get(t, 1)
        type_lines.append(f"{t} ({count})")
    prompt += f"- Question types: {', '.join(type_lines)}\n"

    # Include sub-topics if provided
    if parameters.get("subtopics"):
        prompt += f"- Sub-topics: {', '.join(parameters['subtopics'])}\n"

    # Include keywords if provided
    if parameters.get("keywords"):
        prompt += f"- Context keywords: {', '.join(parameters['keywords'])}\n"

    # Include target audience if provided
    if parameters.get("audience"):
        prompt += f"- Target audience: {parameters['audience']}\n"

    # Specify language if not English
    if parameters.get("language", "en") != "en":
        prompt += f"- Language: {parameters['language']}\n"

    # Indicate whether explanations should be included
    prompt += f"- Include explanations: {'Yes' if parameters.get('include_explanations', False) else 'No'}\n"

    # Add maximum length per question if specified
    if parameters.get("max_length"):
        prompt += f"- Maximum length per question: {parameters['max_length']} words\n"

    # Instruction block for formatting the output correctly
    prompt += (
        "Please format the quiz in Markdown as follows:\n"
        "1. Start with a heading like # Topic Quiz\n"
        "2. For each question, use a subheading like ## Question X: Type (e.g., ## Question 1: Multiple Choice)\n"
        "3. For multiple choice questions, label options as - A), - B), - C), - D)\n"
        "4. For other question types (e.g., Short Answer, True/False, or custom types like Fill-in-the-blank), present the question clearly and provide the answer format expected (e.g., for Short Answer, provide a brief sentence; for True/False, state True or False; for custom types, follow a similar clear format).\n"
        "5. If explanations are requested, include them after each question in a paragraph starting with **Explanation:**\n"
        "6. Make sure all information is factually correct\n"
        "7. Ensure each question's answer matches its explanation, and place the explanation after the answer.\n"
    )

    # Prepare headers for the OpenRouter API request
    headers = {
        "Authorization": f"Bearer {OPENROUTER_API_KEY}",
        "Content-Type": "application/json"
    }

    # Prepare the payload for the API call
    payload = {
        "model": MODEL,
        "messages": [
            {"role": "user", "content": prompt}
        ]
    }

    try:
        # Send POST request to OpenRouter API with timeout set to 25 seconds
        response = requests.post(OPENROUTER_URL, headers=headers, json=payload, timeout=25)
        response.raise_for_status()  # Raise exception for HTTP errors
        data = response.json()

        # Extract quiz content from the API response
        quiz_text = data["choices"][0]["message"]["content"]
        print(f"Raw API Response: {quiz_text}")  # Debug: Log raw API response

        # Handle empty or invalid responses
        if not quiz_text or not quiz_text.strip():
            return {
                "quiz_text": "Error: No quiz content generated.\n\nThe API returned an empty response. This might be due to rate limits (10 requests/min, 50/day) or an unexpected response format."
            }

        # Return the generated quiz text
        return {
            "quiz_text": quiz_text
        }

    except requests.exceptions.Timeout:
        # Handle timeout error
        print("Error: OpenRouter API request timed out after 25 seconds.")
        return {
            "quiz_text": "Error: API request timed out.\n\nThe request to the OpenRouter API timed out after 25 seconds. This might be due to network issues or the API being slow to respond. Please try again later."
        }

    except requests.exceptions.RequestException as e:
        # Handle general request failure
        print(f"Error: OpenRouter API request failed: {str(e)}")
        return {
            "quiz_text": f"Error: API request failed.\n\nThe request to the OpenRouter API failed: {str(e)}. Please check your network connection or try again later."
        }


@app.route('/')
def index():
    """Render the main index.html template."""
    return render_template('index.html')


@app.route('/generate_quiz', methods=['POST'])
def generate_quiz_endpoint():
    """API endpoint to receive quiz generation parameters and return the generated quiz."""
    parameters = request.get_json()
    result = generate_quiz(parameters)
    return jsonify(result)


# Run the Flask app in debug mode when executed directly
if __name__ == '__main__':
    app.run(debug=True)
